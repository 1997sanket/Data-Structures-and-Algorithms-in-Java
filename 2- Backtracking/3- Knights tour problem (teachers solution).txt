import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/*
        Problem
        Given 8x8 chess board, make sure the Knight visits all the cells

        Algo
        1. Choices - we can go in 8 directions (down, up, right, left)
        2. Constraints - don't go outside matrix and the cell should be not visited.
        3. Recursion - after successfully placing one knight do the same for next cell in the choice.
        4. Goal - When we have reached all the cells then stop.

        Caveats in this problem
        1. Notice we can't go from 1 to 64, we HAVE to go from 0 to 63.
        2. We cannot start 1 from (0,0) cell.
        3. We need to follow certain order when choosing our choices.
                -Here we are following anti-clockwise direction
                   - starting from downwards right we go till downwards left.

       Read more from the book
 */

public class Main {

    // (2,1) -> downwards right
    // (1,2) -> rightwards right
    // (-1,2) -> rightwards left
    // (-2,1) -> upwards right
    // (-2,-1) -> upwards left
    // (-1,-2) -> leftwards right
    // (1, -2) -> leftwards left
    // (2,-1) -> downwards left
    private static int [] rowChoices = {2, 1, -1, -2, -2, -1, 1, 2};
    private static int [] colChoices = {1, 2,  2,  1, -1, -2, -2, -1};

    public static void main(String[] args) {

        int [][] arr = {
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0}
        };

        arr[0][0] = 1;	//Since we are starting from 1st but cannot check it, we mark it as visited and pass 1 as counter
        if(knightsTour(arr, 0, 0,1)) {

            //print the board
            for(int i=0; i<arr.length; i++) {
                for(int j=0; j<arr[i].length; j++) {
                    System.out.print(arr[i][j] + " ");
                }
                System.out.println();
            }
        }
    }

    private static boolean knightsTour(int[][] arr, int row, int col, int counter) {

        //5. Goal (base condition)
        if(counter == 64) return true;

        int i,j;
        //1. Choices
        for(int k=0; k<rowChoices.length; k++) {
            i = row + rowChoices[k];
            j = col + colChoices[k];

            //2. Constraint
            if(isSafe(arr, i, j)) {

                    counter++;
                    arr[i][j]=counter;

                    //3. Recursion
                    if(knightsTour(arr, i, j, counter)) {
                        return true;
                    }

                    //4. Backtracking (if recursive call fails)
                    counter--;
                    arr[i][j] = 0;
            }

        }

        //If for loop is complete that means all cell are done and knight cannot be placed anywhere
        return false;

    }

    private static boolean isSafe(int[][] arr, int row, int col) {
        return(row>=0 && row<arr.length &&
                col>=0 && col<arr.length &&
                arr[row][col]==0);
    }
}