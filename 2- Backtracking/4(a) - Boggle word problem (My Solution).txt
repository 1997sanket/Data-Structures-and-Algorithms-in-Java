import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/*
    Problem
    - Find the words given in the dictionary in the given matrix
    - Letters in the matrix can be repeated in different cells.
    - For a given word, don't visit the same cell twice.


    Backtracking Concept
       Choices
        - we can search in 8 directions

       Constraints
        - Stay within the matrix
        - dont visit the same cell twice

       Recursion
        - Here I am using recursion to select my choices

       Backtracking
        - If recursion fails, mark the cell unvisited again

       Goal
        - When counter for a word is equal to the length of the word




    Algo
        1. Traversing the dictionary.
        2, Sending one word at a time to the function.
        3. Along with the word, the position of the first letter of the word is also sent.
        4. For each word, loop through the letters of the word to find in adjacent cells.
        5. Here I'm using Recursion to make choices.

 */

class Position {
    int i;
    int j;

    public Position(int i, int j) {
        this.i = i;
        this.j = j;
    }
}

public class Main {

    //To know which cells are visited for a particular word.
    private static int [][] visited;

    public static void main(String[] args) {

        //Matrix
        char [][] arr = {
                {'T','Y','R','S'},
                {'N','U','A','K'},
                {'Z','F','E','O'},
                {'A','C','B','O'}
        };

        //Dictionary of words.
        List<String> words = List.of(
           "RAY",
           "BOOKS",
           "HELLO",
           "AUNT",
           "FAKE"
        );

        //We pass each word in the function
        for(String word : words) {

            //For every word there will be a new visited matrix
            visited = new int [arr.length][arr.length];

            //We will first find the position of the first letter of the word and then will send that position to the function.
            Position p = findFirstLetterPosition(arr, word);

            //If the first letter is not found then don't call the function
            if(p.i >=0) {
                if(boogle(arr, p.i, p.j, word, 0)) System.out.println(word);
            }

        }
    }

    //TO find position of the first letter of the word
    private static Position findFirstLetterPosition(char[][] arr, String word) {

        for(int i=0; i< arr.length; i++) {
            for(int j=0; j<arr[i].length; j++) {
                if(arr[i][j] == word.charAt(0)) return new Position(i,j);
            }
        }

        //If the letter is not present
        return new Position(-1,-1);
    }

    private static boolean boogle(char[][] arr, int row, int col, String word, int counter) {

        //Goal
        if(counter == word.length()) return true;

        //Constraints
        if(isValid(arr, row, col)) {

            //check if the cell has letter same as first letter of the word
            char [] letters = word.toCharArray();

            //Looping through the characters of the word to find in the matrix
            for(int i=0; i<letters.length; i++) {

                //If character is present in the matrix
                if(arr[row][col] == letters[i]) {

                    //mark visited
                    visited[row][col] = 1;

                    //counter keeps track of how many letters are found.
                    counter++;

                    //(Recursion and Choices) Do the same for adjacent cells, going anti-clockwise

                    //south
                    if(boogle(arr, row+1, col, word, counter)) return true;
                    //south-east
                    if(boogle(arr, row+1, col+1, word, counter)) return true;
                    //east
                    if(boogle(arr, row, col+1, word, counter)) return true;
                    //north-east
                    if(boogle(arr, row-1, col+1, word, counter)) return true;
                    //north
                    if(boogle(arr, row-1, col, word, counter)) return true;
                    //north-west
                    if(boogle(arr, row-1, col-1, word, counter)) return true;
                    //west
                    if(boogle(arr, row, col-1, word, counter)) return true;
                    //south-west
                    if(boogle(arr, row+1, col-1, word, counter)) return true;


                    //Backtracking, if a letter is not found in any adjacent cell
                    visited[row][col] = 0;
                    counter--;
                }
            }

            //if the letter is not found in the loop
            return false;

        }

        //if the position is not valid
        return false;
    }

    //cell should be withing the matrix, and it should not be visited for this particular word
    private static boolean isValid(char[][] arr, int row, int col) {
        return(row>=0 && row<arr.length &&
                col>=0 && col<arr.length &&
                visited[row][col]==0);
    }
}