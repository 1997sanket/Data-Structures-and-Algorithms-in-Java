package com.kamble.demo;

/*
    Algo
        We have two choice
            either we can include and Item or exclude it.
            we have to calculate profit for both and then select max between them.

    Dynamic Programming
        In order to make this program time efficient, we need memoization.
        So how do we know how to create memo array ? should it be a 1D or 2D array ?

        Ans
            So here, since the knapSack() function is called recursively.
            Each time we are sending next index of the item array, so we definitely need 1D array of length Items array + 1 ( +1 for the base condition)
            And each time we are calling knapSack, we are also send reduced capacity after including an Item.
                SO in order to cover all cases of different possible capacities, we need to 0 to capacity 1D array as well.
                For each item we need to cover a capacity case.

            Hence, we need a 2D array of size (items.length + 1) x (capacity + 1) [remember that extra array block +1 is covering base condition]


    Note
        You don't have to trace each recursion call, just write the correct formula and make sure the base case is correct.
 */

import java.util.Arrays;

class Item {
    int weight;
    int price;

    public Item(int weight, int price) {
        this.weight = weight;
        this.price = price;
    }
}

public class Main {

    private static int[][] memo;

    public static void main(String[] args) {

        Item[] items = {
          new Item(7, 15),
          new Item(4, 8),
          new Item(4, 8)
        };

        int capacity = 10;

        //Create memo array from the above inputs.
        memo = new int[items.length +1][capacity + 1];

        //initialize memo blocks with -1
        for(int i=0; i< memo.length; i++) {
            for(int j=0; j<memo[i].length; j++) {
                memo[i][j] = -1;
            }
        }

//        //Print memo array
//        for(int i=0; i< memo.length; i++) {
//            for(int j=0; j<memo[i].length; j++) {
//                System.out.print(" " + memo[i][j] + " ");
//            }
//            System.out.println();
//        }


        int profitPrice = knapSack(items, capacity, 0); //0 is the index from which we are starting.
        System.out.println("Final profit price : " + profitPrice);

        System.out.println("Final memo ");
        //Print memo array
        for(int i=0; i< memo.length; i++) {
            for(int j=0; j<memo[i].length; j++) {
                System.out.print(" " + memo[i][j] + " ");
            }
            System.out.println();
        }

    }

    private static int knapSack(Item[] items, int capacity, int index) {

        //base condition (if no items left or the bag is full then return 0.
        if((index == (items.length)) || capacity == 0) return 0;

        //check if the solution already exists in the memo
        if(memo[index][capacity] != -1) return memo[index][capacity];

        //declare 2 variables for getting profit for including and excluding an item
        int incl = 0;
        int excl = 0;

        //If weight of the current item is less than or equal to the capacity, then include it and recursively do the same for next items.
        if(items[index].weight <= capacity) {
            int newCapacity = capacity - items[index].weight;   //after including capacity will decrease
            incl = items[index].price + knapSack(items, newCapacity, index+1);  //remember not to change the original index variable by doing "index++"
        }

        //Now calculate the profit price if we exclude the current item.
        excl = knapSack(items, capacity, index+1); //remember not to change the original index variable by doing "index++"

        //now check which choice gives us the best profit.
        int result = Math.max(incl, excl);

        //after getting the result, store it in the memo
        memo[index][capacity] = result;

        return result;
    }
}