package com.kamble.demo;

/*
    Problem
        1. There are infinite number of coins for the given denominations.
        2. Find the minimum no of coins using which the total can match the given amount.

    Algo
        Whenever you come across problems which have multiple levels of recursion,
        take input in such a way, that there is only 1 level of recursive calls.
        For eg: In this problem, if we take denominations as [1,2,3] and amount = 1.

        Diagram
                                    f(coins, 1, 0) = 0 + 1

    f(coins, 0, 0)  (won't be calculated for i=1, returns MAX value)  (won't be calculated for i=2, returns MAX value)




    This problem is like Fibonacci and Stairs problem on steroids.
 */

public class Main {

    private static int[][] memo;

    public static void main(String[] args) {
        int[] coins = {1, 3, 5, 2};
        int amount = 7;

        //build memo array from the input
        memo = new int[coins.length + 1][amount + 1];
        for(int i=0; i<memo.length; i++) {
            for(int j=0; j<memo[i].length; j++) {
                memo[i][j] = -1;
            }
        }

        int minNoOfCoins = coinChange(coins, amount, 0);
        System.out.println("Min no of coins from the given denominations to get the amount : " + minNoOfCoins);

        System.out.println("Final MEMO array : ");
        for(int i=0; i<memo.length; i++) {
            for(int j=0; j<memo[i].length; j++) {
                System.out.print(" " + memo[i][j] + " ");
            }
            System.out.println();
        }
    }

    private static int coinChange(int[] coins, int amount, int k) {

        //if amount is completed.
        if(amount == 0) return 0;

        //IF value is available in the memo then return it.
        if(memo[k][amount] != -1) return memo[k][amount];

        int result = Integer.MAX_VALUE; //Initially we consider total No of coins to be Maximum allowed in java.
        for(int i=0; i<coins.length; i++) {

            if(coins[i] <= amount) {
                int subResult = coinChange(coins, (amount - coins[i]), i);

                //Consider the sub result only if it is less than the current result.
                if((subResult+1) < result) {
                    result = subResult + 1; //Adding 1 to consider the current denomination, because we are returning 0 at base condition.
                }
            }
        }

        memo[k][amount] = result;   //Memoizing
        return result;

    }
}